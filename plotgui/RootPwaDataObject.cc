
///////////////////////////////////////////////////////////////////////////
//
//    Copyright 2010
//
//    This file is part of rootpwa
//
//    rootpwa is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    rootpwa is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with rootpwa.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------
// File and Version Information:
// $Rev:: 836                         $: revision of last commit
// $Author:: schmeing                 $: author of last commit
// $Date:: 2011-12-21 12:31:38 +0100 #$: date of last commit
//
// Description:
//      Code file for the CompassPwaFileObject class that provides
//		functionality to read in fit results and integrals from
//		txt files generated by Compass pwa
//
//
// Author List:
//      Stephan Schmeing          TUM            (original author)
//
//
//-------------------------------------------------------------------------

#include <iostream>
#include <complex>

#include <TList.h>
#include <TKey.h>

#include "reportingUtils.hpp"

#include "RootPwaDataObject.h"

using namespace std;
using namespace rpwa;

bool RootPwaDataObject::_Debug = false;

// Returns if a File has not been yet loaded and prints an error message if that is the case
bool RootPwaDataObject::FileNotLoaded(){
	if( !_DataFile ){
		printErr << "No file is loaded. Load a file before trying to select a tree.\n";
		return 0;
	}

	return 0;
}

// Deletes all elements in TreeMap and clears the map
void RootPwaDataObject::EmptyTreeMap(){
	//Deletes all entries
	for ( map<double, fitResult *>::const_iterator it = _TreeMap.begin(); it != _TreeMap.end(); ++it){ // Loops over the whole tree
		delete it->second;
	}

	_TreeMap.clear();
}

// Determines the start and end value of the x-axis for the histograms
void RootPwaDataObject::XAxisParameters( double& from, double& to ) const{
	map<double, fitResult *>::const_iterator it = _TreeMap.begin(); // First element of map

	if( _TreeMap.size() < 2){
		from = it->first-0.01;
		to = it->first+0.01;
	}
	else{
		from = it->first*3/2;
		if( _Debug ){
			printDebug << "Plot from tmp: " << from << '\n';
		}
		from -= (++it)->first*1/2;
		if( _Debug ){
			printDebug << "Plot from final: " << from << '\n';
		}
		it = _TreeMap.end(); // Element after the last element of map
		to = (--it)->first*3/2;
		if( _Debug ){
			printDebug << "Plot to tmp: " << to << '\n';
		}
		to -= (--it)->first*1/2;
		if( _Debug ){
			printDebug << "Plot to final: " << to << '\n';
		}
	}
}

// Default constructor
RootPwaDataObject::RootPwaDataObject():
	_DataFile(0),
	_DataTree(0),
	_DataBranch(0),
	_DataFileName(""),
	_DataTreeName(""),
	_DataBranchName(""),
	_TreeMap(){
}

// Destructor
RootPwaDataObject::~RootPwaDataObject(){
	EmptyTreeMap();
	delete _DataTree;
	delete _DataFile;
	delete _DataBranch;
}

// Returns the filename of the loaded file
const string& RootPwaDataObject::DataFileName() const{
	return _DataFileName;
}

// Returns the treename of the selected tree
const string& RootPwaDataObject::DataTreeName() const{
	return _DataTreeName;
}

// Returns the branchname of the selected branch
const string& RootPwaDataObject::DataBranchName() const{
	return _DataBranchName;
}

// Loading the given root tree file
TFile *RootPwaDataObject::LoadFile( string FileString ) {
	if( _DataFile ){
		printErr << "There is already a File loaded. Clear the object before use.\n";
		return 0;
	}

	printInfo << "Loading File " << FileString << '\n';
	_DataFile = new TFile( FileString.c_str(),"READ","PWA fit results", 1);
	if( _DataFile->IsZombie() ){
		delete _DataFile;
		_DataFile = 0;
		printErr << "Something went wrong loading \"" << FileString << "\".\n";
		return 0;
	}

	_DataFileName = FileString.substr( FileString.find_last_of('/') + 1 ); // Only store filename and not the directory
	return _DataFile;
}

// Reads the names of all trees in the file and returns it in a std::list& given as parameter, returns the number of found trees
unsigned int RootPwaDataObject::TreesInFile( list<string>& TreeList ){
	if( FileNotLoaded() ){
		return 0;
	}

	TreeList.clear();
	TList *ObjectList = _DataFile->GetListOfKeys(); // List of objects stored in the file (trees, histograms, functions, ...)
	TKey *tmp;
	unsigned int i=0;

	while( ( tmp = static_cast<TKey *>(ObjectList->At(i)) ) ){
		if( _Debug){
			printDebug << tmp->GetClassName() << ':' << tmp->GetName() << '\n';
		}

		if( string( tmp->GetClassName() ) == "TTree" ){
			TreeList.push_back( string( tmp->GetName() ) );
		}

		++i;
	}

	TreeList.sort();
	TreeList.unique();

	return TreeList.size();
}

// Selecting root tree in _DataFile by name: Returns Null pointer if tree with given name does not exist
TTree *RootPwaDataObject::SelectTree( std::string TreeName ){
	if( FileNotLoaded() ){
		return 0;
	}

	if( _DataTree ){
		printErr << "There is already a tree selected. Clear the object before reuse.\n";
		return 0;
	}

	_DataTree = static_cast<TTree *>( _DataFile->Get( TreeName.c_str() ) );

	if( _DataTree ){
		_DataTreeName = TreeName;
	}

	return _DataTree;
}

// Reads the names of all branches in the tree and returns it in a std::list& given as parameter, returns the number of found branches
unsigned int RootPwaDataObject::BranchesInTree( list<string>& BranchList ){
	if( !_DataTree ){
		printErr << "No data tree selected. Select one before trying to select its branch.\n";
		return 0;
	}

	BranchList.clear();
	TObjArray *ObjectList = _DataTree->GetListOfBranches(); // List of branches in the tree
	TBranch *tmp;
	unsigned int i=0;

	while( ( tmp = static_cast<TBranch *>(ObjectList->At(i)) ) ){
		if( _Debug){
			printDebug << tmp->GetClassName() << ':' << tmp->GetName() << '\n';
		}

		if( string( tmp->GetClassName() ) == "rpwa::fitResult" ){
			// Object is a fitResult branch
			BranchList.push_back( string( tmp->GetName() ) );
		}

		++i;
	}

	return BranchList.size();
}

// Selecting branch in _DataTree by name and returns if selection was successful (if branch exists)
TBranch *RootPwaDataObject::SelectBranch( string BranchName ){
	if( !_DataTree ){
		printErr << "No data tree selected. Select one before trying to select its branch.\n";
		return 0;
	}

	if( _DataBranch ){
		printErr << "There is already a branch selected. Clear the object before reuse.\n";
		return 0;
	}

	_DataBranch = static_cast<TBranch *>( _DataTree->GetBranch( BranchName.c_str() ) );

	if( _DataBranch ){
		_DataBranchName = BranchName;
	}

	return _DataBranch;
}

const vector<string> *RootPwaDataObject::WavesInTree() const{
	if( !_DataTree ){
		printErr << "No data tree selected. Select one before trying to get its waves.\n";
		return 0;
	}

	if( !_DataBranch ){
		printErr << "No data branch selected. Select one before trying to get the waves of the tree.\n";
		return 0;
	}

	const fitResult *TmpFitResult = 0;
	_DataBranch->SetAddress(&TmpFitResult);

	// If tree has entries
	if( _DataBranch->GetEntries() ){
		// Get first Entry in Tree
		_DataBranch->GetEntry(0);
		return &( TmpFitResult->waveNames() );
	}
	else{
		return 0;
	}
}

// Creates a map of fitResults out of _DataTree sorted by massBinCenter only inserting the fitResults with the Highest logLikelihood for each massBinCenter, returns number of entries in the map
unsigned int RootPwaDataObject::MapTreeByMassWithHighestLikelihood(){
	EmptyTreeMap();

	if( !_DataBranch ){
		printErr << "No data branch selected. Select one before trying to map the tree.\n";
		return 0;
	}

	const fitResult *TmpFitResult = 0;
	fitResult *MemFitResult;
	_DataBranch->SetAddress(&TmpFitResult);

	 // Loop over all fitResults in tree
	Long64_t NEntries = _DataBranch->GetEntries();
	for (Long64_t i=0; i<NEntries; ++i){
		_DataBranch->GetEntry(i);
		pair<map<double, fitResult *>::iterator,bool> InsertAttempt = _TreeMap.insert( pair<double, fitResult *>( TmpFitResult->massBinCenter(), 0 ) ); // 0 pointer just a dummy, has to be filled before use of map!!!
		if( InsertAttempt.second ){ // fitResult was successfully inserted
			// Copy the fitResult from root into memory and add the correct pointer
			MemFitResult = new fitResult( *TmpFitResult );
			if( MemFitResult ){
				InsertAttempt.first->second = MemFitResult;
			}
			else{
				_TreeMap.erase( InsertAttempt.first ); // FitResult could not be created, so empty tree entry is deleted
				printErr << "Could not create new fitResult (Insufficient memory\?\?)\n";
			}
		}
		else{ // fitResult could not be inserted, because an object with equal massBinCenter already exists
			if( InsertAttempt.first->second->logLikelihood() <= TmpFitResult->logLikelihood() ){ // Likelihood of currently mapped fitResult is lower then the new one
				// Copy the fitResult from root into memory and add the correct pointer
				MemFitResult = new fitResult( *TmpFitResult );
				if( MemFitResult ){
					delete InsertAttempt.first->second; // Deletes the old fitResult object
					InsertAttempt.first->second = MemFitResult; // Exchange fitResult
				}
				else{
					printErr << "Could not create new fitResult (Insufficient memory\?\?)\n";
				}
			}
		}
	}

	return _TreeMap.size();
}

// Creates a root histogram of the intensity out of the fitResults in map over the sorting parameter and the spacing between elements has to be constant
TH1F *RootPwaDataObject::IntensityHist( const string& WaveName, const string& TitleXAxis ) const{
	if( _TreeMap.size() < 1){
		printErr << "Data tree contains no element.\n";
		return 0;
	}

	// Determine start (sorting parameter of first element - step size/2) and end value (sorting parameter of last element + step size/2) of histograms x-axis
	double from, to;
	XAxisParameters( from, to );

	TH1F *Hist = new TH1F( (string("IntHist") += WaveName).c_str(), (string("Intensity Histogram: ") += WaveName).c_str(), _TreeMap.size(),from,to);

	// Filling the histogram
	int WaveIndex = 0;
	unsigned int CurrentBin = 1; // Bin 0 is the underflow bin
	map<double, fitResult *>::const_iterator it;

	for ( it = _TreeMap.begin(); it != _TreeMap.end(); ++it){ // Loops over the whole tree
		if( _Debug ){
			printDebug << "Adding MassBin " << it->first << '=' << it->second->massBinCenter() << '\n';
		}
		if( it->second->waveName(WaveIndex) != WaveName ){
			WaveIndex = it->second->waveIndex(WaveName);
		}

		if( _Debug ){
			printDebug << "WaveIndex " << WaveIndex << ": Intensity " << it->second->intensity(WaveIndex) << '\n';
		}

		if( WaveIndex == -1 ){
			printWarn << CurrentBin << ". bin empty since \"" << WaveName << "\" does not exist in this fitResult\n";
		}
		else{
			Hist->SetBinContent(CurrentBin, it->second->intensity(WaveIndex) );
			Hist->SetBinError(CurrentBin, it->second->intensityErr(WaveIndex) );
		}

		++CurrentBin;
	}

	Hist->SetXTitle( TitleXAxis.c_str() );
	Hist->SetYTitle( "Intensity" );

	return Hist;
}

// Creates a root histogram of the coherent sum out of the fitResults in map over the sorting parameter and the spacing between elements has to be constant (The deletion of the histogram is responsibility of calling function)
TH1F *RootPwaDataObject::CoherentSumHist( const list<string>& WaveNames, const std::string& TitleXAxis ) const{
	if( _TreeMap.size() < 1){
		printErr << "Data tree contains no element.\n";
		return 0;
	}

	// Determine start (sorting parameter of first element - step size/2) and end value (sorting parameter of last element + step size/2) of histograms x-axis
	double from, to;
	XAxisParameters( from, to );

	// Creating list of WaveIndices out of WaveNames
	map<double, fitResult *>::const_iterator it = _TreeMap.begin();
	list<string>::const_iterator it2;
	vector<unsigned int> waveIndices;
	vector<unsigned int> prodAmpIndices;
	vector<unsigned int> tmpIndices;
	int waveIndex;

	for ( it2 = WaveNames.begin(); it2 != WaveNames.end(); ++it2){ // Loops over the whole list
		waveIndex = it->second->waveIndex( it2->data() );

		if( waveIndex == -1 ){
			printWarn << it2->data() << " is missing in this fitResult";
		}
		else{
			waveIndices.push_back( static_cast<unsigned int>(waveIndex) );
			tmpIndices = it->second->prodAmpIndicesForWave(waveIndex);
			prodAmpIndices.insert(prodAmpIndices.end(), tmpIndices.begin(), tmpIndices.end() );
		}
	}

	// Filling the histogram
	TH1F *Hist = new TH1F( "CohSumHist", "Coherent Sum Histogram", _TreeMap.size(),from,to);
	unsigned int CurrentBin = 1; // Bin 0 is the underflow bin


	for ( it = _TreeMap.begin(); it != _TreeMap.end(); ++it){ // Loops over the whole tree
		if( _Debug ){
			printDebug << "Adding MassBin " << it->first << '=' << it->second->massBinCenter() << '\n';
		}

		Hist->SetBinContent(CurrentBin, it->second->intensity( waveIndices ) );
		Hist->SetBinError(CurrentBin, it->second->intensityErr( prodAmpIndices ) );

		++CurrentBin;
	}

	Hist->SetXTitle( TitleXAxis.c_str() );
	Hist->SetYTitle( "Coherent Sum" );

	return Hist;
}

///< Creates a root histogram of the phase shift between wave A and B out of the fitResults in map over the sorting parameter and the spacing between elements has to be constant (The deletion of the histogram is responsibility of calling function)
TH1F *RootPwaDataObject::PhaseShiftHist( const string& WaveNameA, const string& WaveNameB, const string& TitleXAxis ) const{
	if( _TreeMap.size() < 1){
		printErr << "Data tree contains no element.\n";
		return 0;
	}

	// Determine start (sorting parameter of first element - step size/2) and end value (sorting parameter of last element + step size/2) of histograms x-axis
	double from, to;
	XAxisParameters( from, to );

	TH1F *Hist = new TH1F( ((string("PhaseShiftHist") += WaveNameA) += WaveNameB).c_str(), (((string("Phase Shift Histogram: ") += WaveNameA) += string(" ")) += WaveNameB).c_str(), _TreeMap.size(),from,to);

	// Filling the histogram
	int WaveIndexA = 0;
	int WaveIndexB = 0;
	unsigned int CurrentBin = 1; // Bin 0 is the underflow bin
	map<double, fitResult *>::const_iterator it;

	for ( it = _TreeMap.begin(); it != _TreeMap.end(); ++it){ // Loops over the whole tree
		if( _Debug ){
			printDebug << "Adding MassBin " << it->first << '=' << it->second->massBinCenter() << '\n';
		}

		if( it->second->waveName(WaveIndexA) != WaveNameA ){
			WaveIndexA = it->second->waveIndex(WaveNameA);
		}
		if( it->second->waveName(WaveIndexB) != WaveNameB ){
			WaveIndexB = it->second->waveIndex(WaveNameB);
		}

		if( WaveIndexA == -1 ){
			printWarn << CurrentBin << ". bin empty since \"" << WaveNameA << "\" does not exist in this fitResult\n";
		}
		else if( WaveIndexB == -1 ){
			printWarn << CurrentBin << ". bin empty since \"" << WaveNameB << "\" does not exist in this fitResult\n";
		}
		else{
			Hist->SetBinContent(CurrentBin, it->second->phase(WaveIndexA,WaveIndexB) );
			Hist->SetBinError(CurrentBin, it->second->phaseErr(WaveIndexA,WaveIndexB) );
		}

		++CurrentBin;
	}

	Hist->SetXTitle( TitleXAxis.c_str() );
	Hist->SetYTitle( "Phase Shift" );

	return Hist;
}

// Clears the file object without calling destructor of the _DataObject;
void RootPwaDataObject::Clear(){
	_DataTree = 0;
	_DataFile = 0;
	_DataBranch = 0;

	_DataFileName = "";
	_DataTreeName = "";
	_DataBranchName = "";

	EmptyTreeMap();
}

// Clears the file object and calls destructor of the _DataObject;
void RootPwaDataObject::Empty(){
	delete _DataTree;
	delete _DataFile;
	delete _DataBranch;

	Clear();
}

// Prints all important variables of class
ostream& RootPwaDataObject::Print( ostream& Out ) const{
	Out << "If you find this, you can keep it" << '\n';

	return Out;
}
