///////////////////////////////////////////////////////////////////////////
//
//    Copyright 2010
//
//    This file is part of rootpwa
//
//    rootpwa is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    rootpwa is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with rootpwa.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------
// File and Version Information:
// $Rev:: 862                         $: revision of last commit
// $Author:: schmeing                 $: author of last commit
// $Date:: 2012-07-06 13:54:31 +0200 #$: date of last commit
//
// Description:
//      Code file for the CompassPwaFileFitResults class that provides
//		functionality to read in fit results integrals from
//		txt files generated by Compass pwa and store them
//
//
// Author List:
//      Stephan Schmeing          TUM            (original author)
//
//
//-------------------------------------------------------------------------

#include <iostream>
#include <map>

#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/replace.hpp>

#include "reportingUtils.hpp"
#include "conversionUtils.hpp"
#include "particleDataTable.h"

#include "CompassPwaFileFitResults.h"

using namespace std;
using namespace rpwa;
using namespace boost;

bool CompassPwaFileFitResults::_Debug = false;

// Returns total number of waves (Sum over all sections)
unsigned int CompassPwaFileFitResults::TotalNumWaves() const{
	unsigned int TotalNumWaves = 0;

	for( unsigned int i=0; i < _WaveNames.size(); ++i ){
		TotalNumWaves += _WaveNames[i].size();
	}

	return TotalNumWaves;
}

// Returns the size of the total covariance matrix if equal ranks for all sections are enforced (except flat wave)
unsigned int CompassPwaFileFitResults::TotalCovMatrixSizeEqualRanks() const{
	return ( (TotalNumWaves() - 1) * MaxRank() + 1 ) * 2; // Flat wave has always rank 1 and each wave has a real and imaginary part
}

// Default constructor
CompassPwaFileFitResults::CompassPwaFileFitResults():
	_NumEvents(0),
	_LogLikelihood(0){
}

// Destructor
CompassPwaFileFitResults::~CompassPwaFileFitResults(){
}

// Returns _NumEvents
unsigned int CompassPwaFileFitResults::NumEvents() const{
	return _NumEvents;
}

// Returns _LogLikelihood
double CompassPwaFileFitResults::LogLikelihood() const{
	return _LogLikelihood;
}

// Returns number of reflectivity sections
unsigned int CompassPwaFileFitResults::NumSections() const{
	return _Ranks.size();
}

// Returns _Rank[Section]
unsigned int CompassPwaFileFitResults::Rank( unsigned int Section ) const{
	return _Ranks[Section];
}

// Returns _WaveNames
const vector< vector<string> >& CompassPwaFileFitResults::WaveNames() const{
	return _WaveNames;
}

// Returns _WaveNames[Section]
const std::vector<string>& CompassPwaFileFitResults::WaveNames( unsigned int Section ) const{
	return _WaveNames[Section];
}

// Returns _WaveNames in rootpwa style
vector<string>& CompassPwaFileFitResults::ProdAmpNamesRootPwa( vector<string>& Destination ) const{
	unsigned int maxRank = MaxRank();

	Destination.clear();
	Destination.resize( ( TotalNumWaves() - 1 ) * maxRank + 1 ); // Each rank for each wave has an entry, but the flatwave has only one entry

	if( _Debug ){
		printDebug << "Resized to " << ( TotalNumWaves() - 1 ) * maxRank + 1 << " strings in Destination\n";
	}

	TComplex ProdAmpTmp(0,0);

	unsigned int k; // Current rank
	unsigned int j=0; // Next free position in Destination
	for( unsigned int s=0; s < _WaveNames.size(); ++s ){ // Section
		if( _Debug ){
			printDebug << "Accessing " << j << '\n';
		}

		if( "FLAT" == _WaveNames[s][0] ){
			CompassPwaNameToRootPwaName( Destination[j++], "FLAT" );
		}
		else{
			for( unsigned int i=0; i < _WaveNames[s].size(); ++i ){
				for( k = 0; k < maxRank; ++k ){
					CompassPwaNameToRootPwaName( Destination[j++], _WaveNames[s][i], k );
				}
			}
		}
	}

	return Destination;
}

// Returns _FitResults[Section]
const TCMatrix& CompassPwaFileFitResults::FitResults( unsigned int Section ) const{
	return _FitResults[Section];
}

// Returns _FitResults in rootpwa style
vector< complex<double> >& CompassPwaFileFitResults::ProdAmpsRootPwa( vector< complex<double> >& Destination ) const{
	unsigned int maxRank = MaxRank();

	Destination.clear();
	Destination.resize( ( TotalNumWaves() - 1 ) * maxRank + 1 ); // Each rank for each wave has an entry, but the flatwave has only one entry

	TComplex ProdAmpTmp(0,0);

	unsigned int k; // Current rank
	unsigned int j=0; // Next free position in Destination
	for( unsigned int s=0; s < _WaveNames.size(); ++s ){ // Section
		if( "FLAT" == _WaveNames[s][0] ){
			ProdAmpTmp = _FitResults[s].get(0,0);
			Destination[j++] = complex<double>( ProdAmpTmp.Re(), ProdAmpTmp.Im() ) * sqrt(_NumEvents); // The intensities has to be multiplied with the number of events in CompassPWA, but not in rootpwa therefore this sqrt has to be multiplied with the production amplitudes
		}
		else{
			for( unsigned int i=0; i < _WaveNames[s].size(); ++i ){
				for( k = 0; k < _Ranks[s]; ++k ){
					ProdAmpTmp = _FitResults[s].get(i,k);
					Destination[j++] = complex<double>( ProdAmpTmp.Re(), ProdAmpTmp.Im() ) * sqrt(_NumEvents); // The intensities has to be multiplied with the number of events in CompassPWA, but not in rootpwa therefore this sqrt has to be multiplied with the production amplitudes
				}

				// Filling up with zeros to enforce equal ranks for all sections (except flat wave)
				for( ; k < maxRank; ++k){
					Destination[j++] = complex<double>( 0, 0 );
				}
			}
		}
	}

	return Destination;
}

// Returns _CovMatrix
const TMatrixT<double>& CompassPwaFileFitResults::CovMatrix() const{
	return _CovMatrix;
}

// Returns _CovMatrix in rootpwa style
TMatrixT<double> &CompassPwaFileFitResults::CovMatrixRootPwa( TMatrixT<double> &Destination ) const{
	if( _Debug ){
		printDebug << "CovMatrix(C"<< _CovMatrix.GetNcols() <<",R"<< _CovMatrix.GetNrows() <<"):\n";
		_CovMatrix.Print();
	}

	unsigned int size = TotalCovMatrixSizeEqualRanks();
	Destination.ResizeTo( size, size );
	Destination.Zero();

	unsigned int maxRank = MaxRank();
	unsigned int CurRanki = 0;
	unsigned int CurRankj = 0;

	unsigned int iCurSection = 0; // Current reflectivity section in rows
	unsigned int jCurSection; // Current reflectivity section in columns
	unsigned int iLastIndexOfSection = _WaveNames[0].size() * _Ranks[0] * 2 - 1; // Row index where the next reflectivity section start
	unsigned int jLastIndexOfSection; // Column index where the next reflectivity section start

	unsigned int iTot = 0; // Corresponding to index i in the covariance matrix with enforced equal ranks
	unsigned int jTot; // Corresponding to index j in the covariance matrix with enforced equal ranks

	for( unsigned int i = 0; static_cast<int>(i) < _CovMatrix.GetNrows(); i += 2 ){
		 // Reset columns
		jTot = 0;
		jCurSection = 0;
		jLastIndexOfSection = _WaveNames[0].size() * _Ranks[0] * 2 - 1;

		// Update reflectivity section
		if( i > iLastIndexOfSection ){
			++iCurSection;
			iLastIndexOfSection += _WaveNames[iCurSection].size() * _Ranks[iCurSection] * 2;
		}

		for( unsigned int j = 0; static_cast<int>(j) <  _CovMatrix.GetNcols(); j += 2 ){
			// Update reflectivity section
			if( j > jLastIndexOfSection ){
				++jCurSection;
				jLastIndexOfSection += _WaveNames[jCurSection].size() * _Ranks[jCurSection] * 2;
			}

			Destination.SetSub( iTot, jTot, _CovMatrix.GetSub(i,i+1,j,j+1) ); // Directly copies a complete 2x2-block of real and imaginary part

			if( ++CurRankj < _Ranks[jCurSection] ){ // CurRankj + 1 is still a rank in the covariance matrix
				jTot += 2;
			}
			else{ // CurRankj + 1 is not a rank in the covariance matrix anymore and the program has to set jTot to the first rank of the next wave in the covariance matrix
				if( "FLAT" == _WaveNames[jCurSection][0] ){
					jTot += 2;
				}
				else{
					jTot += (maxRank-_Ranks[jCurSection]+1)*2;
				}

				CurRankj = 0;
			}
		}

		if( ++CurRanki < _Ranks[iCurSection] ){ // CurRanki + 1 is still a rank in the covariance matrix
			iTot += 2;
		}
		else{ // CurRanki + 1 is not a rank in the covariance matrix anymore and the program has to set iTot to the first rank of the next wave in the covariance matrix
			if( "FLAT" == _WaveNames[iCurSection][0] ){
				iTot += 2;
			}
			else{
				iTot += (maxRank-_Ranks[iCurSection]+1)*2;
			}

			CurRanki = 0;
		}
	}

	if( _Debug ){
		printDebug << "Destination(C"<< Destination.GetNcols() <<",R"<< Destination.GetNrows() <<"):\n";
		Destination.Print();
	}
	Destination *= _NumEvents;
	if( _Debug ){
		printDebug << "DestinationMult(C"<< Destination.GetNcols() <<",R"<< Destination.GetNrows() <<"):\n";
		Destination.Print();
	}

	return Destination;
}

// Returns a map for the covariance matrix as it is needed for root pwa
vector<pair<int, int> >& CompassPwaFileFitResults::CovMatrixMapRootPwa( vector<pair<int, int> >& Destination ) const{
	Destination.clear();

	unsigned int size = TotalCovMatrixSizeEqualRanks() / 2;

	Destination.reserve( size );

	for( unsigned int i=0; i < size; ++i ){
		Destination.push_back( pair<int,int>( i*2, i*2+1 ) );
	}

	return Destination;
}

// Reads the rest of the information from a fit result file stream and returns 0 if no error occurred or a negative number as the error code
bool CompassPwaFileFitResults::ReadIn( std::istream& File ){
	bool Succesful = true; // Is set to false if an error occurs and returned at the end of the function
	stringstream LineStream;
	string Line;

	// Get number of events
	if( _Debug){
		printDebug << "Get number of events" << endl;
	}
	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "       33657"
		LineStream >> _NumEvents;

		if( !_NumEvents ){
			printErr << "Number of events either 0 or not an unsigned int\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "Number of events entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the number of events was expected\n";
		Succesful = false;
	}

	// Get log(likelihood)
	if( _Debug){
		printDebug << "Get log(likelihood)" << endl;
	}
	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": ""
		LineStream >> _LogLikelihood;

		if( !_LogLikelihood ){
			printErr << "log(likelihood) either 0 or not a double\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "log(likelihood) entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the log(likelihood) was expected\n";
		Succesful = false;
	}

	// Get fit status
	if( _Debug){
		printDebug << "Get fit status" << endl;
	}
	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "           0"
		LineStream >> _FitStatus;

		if( LineStream.fail() ){
			printErr << "fit status could not be read\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "log(likelihood) entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the fit status was expected\n";
		Succesful = false;
	}

	// Get number of reflectivity sections
	if( _Debug){
		printDebug << "Get number of reflectivity sections" << endl;
	}
	unsigned int NumSections = 0;

	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "           3"
		LineStream >> NumSections;

		if( !NumSections ){
			printErr << "Number of reflectivity sections either 0 or not a unsigned int\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "Number of reflectivity sections entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the number of reflectivity sections was expected\n";
		Succesful = false;
	}

	// Get number of waves of each reflectivity section
	if( _Debug){
		printDebug << "Get number of waves of each reflectivity section" << endl;
	}
	unsigned int SecNumWaves[NumSections];
	char semicolon = 0;

	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "    1;   45;    7;"
		for( unsigned int i = 0; i < NumSections; ++i){
			SecNumWaves[i] = 0;

			LineStream >> SecNumWaves[i] >> semicolon;

			if( !SecNumWaves[i] ){
				printErr << "Number of waves either 0 or not a unsigned int\n";
				Succesful = false;
			}
			else{
				if( semicolon != ';' ){
					printWarn << "Number of waves separator not a semicolon\n";
					if( _Debug ){
						printDebug << "Separator: '" << semicolon << "'\n";
					}
				}
			}
		}

		LineStream.get(); // Should not work, since line shouldn't have any more characters
		if( LineStream.good() ){
			printWarn << "Numbers of waves line longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the numbers of waves were expected\n";
		Succesful = false;
	}

	// Get rank of each reflectivity section
	if( _Debug){
		printDebug << "Get rank of each reflectivity section" << endl;
	}
	semicolon = 0;
	_Ranks.resize(NumSections);

	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "    1;    2;    2;"
		for( unsigned int i = 0; i < NumSections; ++i){
			_Ranks[i] = 0;

			LineStream >> _Ranks[i] >> semicolon;

			if( !_Ranks[i] ){
				printErr << "Rank either 0 or not an int\n";
				Succesful = false;
			}
			else{
				if( semicolon != ';' ){
					printWarn << "Rank separator not a semicolon\n";
					if( _Debug ){
						printDebug << "Separator: '" << semicolon << "'\n";
					}
				}
			}
		}

		LineStream.get(); // Should not work, since line shouldn't have any more characters
		if( LineStream.good() ){
			printWarn << "Ranks line longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the ranks were expected\n";
		Succesful = false;
	}

	// Get fit results
	if( _Debug){
		printDebug << "Get fit results" << endl;
	}

	_WaveNames.resize(NumSections);
	_FitResults.resize(NumSections);
	for( unsigned int s = 0; s < NumSections; ++s){
		_FitResults[s].ResizeTo(SecNumWaves[s],_Ranks[s]);
	}

	char WaveNameCStr[61];
	string WaveName;
	WaveName.reserve(61);
	unsigned int LastNonEmptyCharacter;
	unsigned int CurRank;
	unsigned int l; // Loop variable equal to j except that it is not reseted to 0 for each section and therefore addresses _FitResults correctly
	unsigned int k; // Loop variable that is needed unchanged in a second loop
	complex<double> FitResultParameter;
	char apostrophe1; // Takes the first bracket character, which should be a apostrophe
	char apostrophe2; // Takes the second bracket character, which should be a apostrophe

	// if( _Debug ){ // Not always including it leads to compiler errors, even if it is not needed
	double RankSumProdAmpsSquared;
	// }

	for( unsigned int s = 0; s < NumSections; ++s){ // Section
		l=0;
		for( unsigned int j = 0; j < SecNumWaves[s]; ++j){
			if( GetNextValidLine( File, LineStream ) ){
				// Example:
				// 'FLAT                                                        '(-0.398790E-15;-0.824390E-15)
				//
				// '1-(0-+)0+ f0(1400) pi S                                     '( 0.209758E+00; 0.145496E+00)
				// '1-(0-+)0+ f0(980) pi S                                      '( 0.000000E+00; 0.000000E+00)( 0.000000E+00; 0.000000E+00)
				LineStream >> apostrophe1;
				LineStream.get( WaveNameCStr, 61 );
				LineStream >> apostrophe2;

				if( _Debug ){
					printDebug << "Name: "<< WaveNameCStr << '\n';
				}

				// if( _Debug ){ // Not always including it leads to compiler errors, even if it is not needed
				RankSumProdAmpsSquared = 0;
				// }

				// Fill the corresponding row of the matrix with the values from the file
				CurRank = min(_Ranks[s],j+1);
				for( k = 0; k < CurRank; ++k){
					LineStream >> FitResultParameter;
					_FitResults[s].set( l, k, FitResultParameter );
					if( _Debug ){
						printDebug << "Rank"<<k<<": " << FitResultParameter << '\n';
						RankSumProdAmpsSquared += norm(FitResultParameter);
					}
				}

				if( _Debug ){
					printDebug << '\n';
				}

				// Fill the rest of the row of the matrix with (0,0), since in the Compass code result parameter that are always 0 are not included
				FitResultParameter = complex<double>(0,0);
				for( ; k < _Ranks[s]; ++k){
					_FitResults[s].set( l, k, FitResultParameter );
				}

				if( LineStream.fail() ){
					printErr << "Reading error in line " << l << " that is supposed to contain a fit result\n";
					Succesful = false;
				}
				else{
					LineStream.get(); // Should not work, since line shouldn't have any more characters
					if( LineStream.good() ){
						printWarn << "Fit result line longer than expected\n";
					}

					if( apostrophe1 != '\'' || apostrophe2 != '\'' ){
						printWarn << "Wave name bracket not an apostrophe\n";
						if( _Debug ){
							printDebug << "Brackets: '" << apostrophe1 << "','"<< apostrophe2 << "'\n";
						}
					}

					WaveName = WaveNameCStr;

					// Chop of following whitespaces
					LastNonEmptyCharacter = WaveName.find_last_not_of(' ');
					WaveName.resize(LastNonEmptyCharacter + 1);

					_WaveNames[s].push_back( WaveName );
					if( _Debug ){
						printDebug << MassBinStart() << '-' << MassBinEnd() << '_' << WaveName << ':' << RankSumProdAmpsSquared * _NumEvents << '\n';
					}
				}

				++l;
			}
			else{
				printErr << "Less wave names found than specified\n";
				Succesful = false;
			}
		}

		// After each section should be an empty line
		if( GetNextValidLine( File, Line ) ){
			if( !Line.empty() ){
				printErr << "More wave names found than specified\n";
				Succesful = false;
			}
		}
		else{
			printErr << "No valid line could be found anymore, but a blank separation line between reflectivity sections was expected\n";
			Succesful = false;
		}


	}

	// Get covariance matrix
	if( _Debug){
		printDebug << "Get covariance matrix" << endl;
	}

	unsigned int CovMatrixSize = 0;
	for( unsigned int s=0; s < NumSections; ++s ){
		CovMatrixSize += SecNumWaves[s]*_Ranks[s]*2; // Real and imaginary entry for each rank of each wave for each section
	}
	_CovMatrix.ResizeTo( CovMatrixSize, CovMatrixSize );

	for( unsigned int i = 0; i<CovMatrixSize; ++i ){
		if( GetNextValidLine( File, LineStream ) ){
			for( unsigned int j = 0; j<CovMatrixSize; ++j ){
				LineStream >> _CovMatrix( i, j );
			}

			if( LineStream.fail() ){
				printErr << "Reading error in a line " << i+1 << " that is supposed to contain covariance matrix values (probably not enough entries)\n";
				Succesful = false;
			}

			if( !LineStream.eof() ){
				printErr << "Row of covariance matrix has too many entries\n";
				Succesful = false;
			}
		}
		else{
			printErr << "Covariance matrix has not enough rows\n";
			Succesful = false;
		}
	}

	// If there are still valid lines, the number of waves in the last section is not correct
	if( GetNextValidLine( File, Line ) ){
		// Some editors put automatically an empty line at the end, so this error has to be caught
		if( !Line.empty() || GetNextValidLine( File, Line ) ){
			printErr << "Covariance matrix has too many rows\n";
			Succesful = false;
		}
	}

	return Succesful;
}

// Returns the highest rank of all sections
unsigned int CompassPwaFileFitResults::MaxRank() const{
	unsigned int MaxRank = 0;

	for( unsigned int i=0; i < _Ranks.size(); ++i ){
		if( _Ranks[i] > MaxRank ){
			MaxRank = _Ranks[i];
		}
	}

	return MaxRank;
}

// Prints all important variables of class
ostream& CompassPwaFileFitResults::Print(ostream& Out) const{
	CompassPwaFileBase::Print( Out );

	Out << "Number of events: " << _NumEvents << '\n';
	Out << "log(likelihood): " << _LogLikelihood << '\n';

	Out << "Ranks: " << _Ranks[0];
	for( unsigned int i=1; i < _Ranks.size(); ++i ){
		Out << " ;" << _Ranks[i];
	}
	Out << '\n';

	for( unsigned int s=1; s < _Ranks.size(); ++s ){ // Sections
		for( unsigned int i=0; i < _WaveNames[s].size(); ++i){
			Out << '\'' << _WaveNames[s][i] << '\'';
			for( unsigned int k=0; k < _Ranks[s]; ++k ){
				Out << _FitResults[s].get(i,k);
			}
			Out << '\n';
		}
	}

	return Out;
}

///< Returns true if CharToCheck is a Number or false if it isn't
bool CompassPwaFileFitResults::IsNumber( char CharToCheck ){
	return ( 47 < CharToCheck ) && ( CharToCheck < 58 );
}

// Converts a CompassPWA wavename into a rootpwa wavename and since rootpwa wavenames additionally include the rank it has to be provided separately (for the flatwave this value does not matter and can be left out)
bool CompassPwaFileFitResults::CompassPwaNameToRootPwaName( std::string& RootPwaDestination, const std::string& CompassPwaSource, unsigned int AddedRank ){
	bool Successful = true;

	if( _Debug ){
		printDebug << "Parsing name \"" << CompassPwaSource << "\"\n";
	}

	if ( "FLAT" == CompassPwaSource ){
		RootPwaDestination = "V_flat";
	}
	else{
		RootPwaDestination = CompassPwaSource;

		if( _Debug ){
			printDebug << "Check first 10 characters\n";
		}

		// Check if first 10 characters are valid
		if( !IsNumber(CompassPwaSource[0]) ){
			printErr << "At first position of the wave name is no number\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[1]) ){
			printErr << "At second position of the wave name is no sign\n";
			Successful = false;
		}
		if( '(' != CompassPwaSource[2] ){
			printWarn << "At third position of the wave name is no bracket\n";
		}
		if( !IsNumber(CompassPwaSource[3]) ){
			printErr << "At fourth position of the wave name is no number\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[4]) ){
			printErr << "At fifth position of the wave name is no sign\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[5]) ){
			printErr << "At sixth position of the wave name is no sign\n";
			Successful = false;
		}
		if( ')' != CompassPwaSource[6] ){
			printWarn << "At seventh position of the wave name is no bracket\n";
		}
		if( !IsNumber(CompassPwaSource[7]) ){
			printErr << "At eighth position of the wave name is no number\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[8]) ){
			printErr << "At ninth position of the wave name is no sign\n";
			Successful = false;
		}
		if( ' ' != CompassPwaSource[9] ){
			printWarn << "At tenth position of the wave name is no space\n";
		}

		if( _Debug ){
			printDebug << "Delete brackets and space in them\n";
		}

		// Remove braces and space in first 10 characters
		RootPwaDestination.erase(9,1);
		RootPwaDestination.erase(6,1);
		RootPwaDestination.erase(2,1);

		if( _Debug ){
			printDebug << "Find and replace isobar\n";
		}

		string Isobar;
		// Translate isobars
		unsigned int NumIsobars = 0;
		const unsigned int nmbDict = 7;
		vector<string> FindVec;

		// {rootpwa, CompassPWA}
		const string IsobarDictionary[nmbDict][2] = {
				{"sigma0",    "(pipi)_S"},
				{"sigma0",    "f0(1400)"},
				{"f0(980)0",    "f0(980)"},
				{"rho(770)0",   "rho"},
				{"f2(1270)0",   "f2"},
				{"rho3(1690)0", "rho3"},
				{"f0(1500)0", "f0(1500)"} };

		for (unsigned int i = 0; i < nmbDict; ++i){
			FindVec.clear();
			find_all( FindVec, RootPwaDestination, IsobarDictionary[i][1] );

			if( _Debug ){
				printDebug << RootPwaDestination << '\n';
				printDebug << "Find: \"" << IsobarDictionary[i][1] << "\" Found: " << FindVec.size() << '\n';
			}

			NumIsobars += FindVec.size();

			if( FindVec.size() > 0 ){
				Isobar = IsobarDictionary[i][0];
				if( IsobarDictionary[i][1] != IsobarDictionary[i][0] ){
					replace_all(RootPwaDestination, IsobarDictionary[i][1], IsobarDictionary[i][0] );
				}
			}
		}

		// Since root has problems with brackets they are deleted
		replace_all(RootPwaDestination, "(", "" );
		replace_all(RootPwaDestination, ")", "" );

		if( NumIsobars != 1 ){
			printErr << "Isobar of wave \"" << CompassPwaSource << "\" is not well-defined\n";
			Successful = false;
		}

		if( _Debug ){
			printDebug << "Isobar: \"" << Isobar << "\"\n";
			printDebug << "Find and replace L\n";
		}

		// Get && Translate L
		char L = 0;

		map<char, char> LDictionary;
		LDictionary['S'] = '0';
		LDictionary['P'] = '1';
		LDictionary['D'] = '2';
		LDictionary['F'] = '3';
		LDictionary['G'] = '4';
		LDictionary['H'] = '5';
		LDictionary['I'] = '6';
		LDictionary['6'] = '6';
		LDictionary['K'] = '7';
		LDictionary['L'] = '8';

		int PosL = RootPwaDestination.find_last_of(' ') + 1;
		map<char,char>::iterator it = LDictionary.find( RootPwaDestination[PosL] );
		if( it == LDictionary.end() ){
			printErr << "L of wave \"" << CompassPwaSource << "\" is not well-defined\n";
			Successful = false;
		}
		else{
			L = it->second;
		}
		RootPwaDestination.erase(PosL-1);

		PosL = RootPwaDestination.find_last_of(' ');
		RootPwaDestination.erase( PosL, 1 );
		RootPwaDestination.insert( PosL, "_00_" ); // The 0s are just place holders
		RootPwaDestination[PosL+1] = L;

		if(_Debug){
			printDebug << particleDataTable::instance();
		}

		const particleProperties *IsobarParticle = particleDataTable::entry( Isobar );
		if( !IsobarParticle ){
			printErr << "Spin of particle " << Isobar << " could not be determined\n";
			Successful = false;
		}
		else{
			if( IsobarParticle->J() > 9 ){
				printErr << "Particle spins with more than one digit have not been implemented into the wave name conversion yet";
				Successful = false;
			}
			else{
				RootPwaDestination[PosL+2] = 48 + IsobarParticle->J();
			}
		}

		if( _Debug ){
			printDebug << "Add rank\n";
		}

		// Insert the rank at the beginning of the wave name
		RootPwaDestination.insert( 0, "V0_" ); // The 0 is just a place holder
		if( AddedRank > 9 ){
			printErr << "Ranks with more than one digit have not been implemented into the wave name conversion yet";
			Successful = false;
		}
		else{
			RootPwaDestination[1] = 48 + AddedRank;
		}

		// At the end rootpwa always writes this
		RootPwaDestination.append(".amp");
	}

	return Successful;
}
