///////////////////////////////////////////////////////////////////////////
//
//    Copyright 2010
//
//    This file is part of rootpwa
//
//    rootpwa is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    rootpwa is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with rootpwa.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------
// File and Version Information:
// $Rev::                             $: revision of last commit
// $Author::                          $: author of last commit
// $Date::                            $: date of last commit
//
// Description:
//      Code file for the CompassPwaFileFitResults class that provides
//		functionality to read in fit results integrals from
//		txt files generated by Compass pwa and store them
//
//
// Author List:
//      Stephan Schmeing          TUM            (original author)
//
//
//-------------------------------------------------------------------------

#include <iostream>
#include <map>

#include <boost/algorithm/string/split.hpp>
#include <boost/algorithm/string/replace.hpp>

#include "reportingUtils.hpp"
#include "conversionUtils.hpp"
#include "particleDataTable.h"

#include "CompassPwaFileFitResults.h"

using namespace std;
using namespace rpwa;
using namespace boost;

bool CompassPwaFileFitResults::_Debug = false;

// Default constructor
CompassPwaFileFitResults::CompassPwaFileFitResults():
	_NumEvents(0),
	_LogLikelihood(0),
	_Rank(0){
}

// Destructor
CompassPwaFileFitResults::~CompassPwaFileFitResults(){
}

// Returns _NumEvents
unsigned int CompassPwaFileFitResults::NumEvents() const{
	return _NumEvents;
}

// Returns _LogLikelihood
double CompassPwaFileFitResults::LogLikelihood() const{
	return _LogLikelihood;
}

// Returns _Rank
unsigned int CompassPwaFileFitResults::Rank() const{
	return _Rank;
}

// Returns _WaveNames
const std::vector<std::string>& CompassPwaFileFitResults::WaveNames() const{
	return _WaveNames;
}

// Returns _WaveNames in rootpwa style
vector<string>& CompassPwaFileFitResults::WaveNamesRootPwa( vector<string>& Destination ) const{
	Destination.clear();
	Destination.resize( _WaveNames.size() * _Rank - _Rank + 1 ); // Each rank for each wave has an entry, but the flatwave has only one entry

	if( _Debug ){
		printDebug << "Reserved " << _WaveNames.size() * _Rank - _Rank + 1 << " strings in Destination\n";
	}

	unsigned int j=0; // Next free position in Destination
	for( unsigned int i=0; i < _WaveNames.size(); ++i ){
		if( _Debug ){
			printDebug << "Accessing " << j << '\n';
		}
		if( "FLAT" == _WaveNames[i] ){
			CompassPwaNameToRootPwaName( Destination[j++], "FLAT" );
		}
		else{
			for( unsigned int k=0; k < _Rank; ++k ){
				CompassPwaNameToRootPwaName( Destination[j++], _WaveNames[i], k );
			}
		}
	}

	return Destination;
}

// Returns _FitResults
const TCMatrix& CompassPwaFileFitResults::FitResults() const{
	return _FitResults;
}

// Returns _FitResults in rootpwa style
vector< complex<double> >& CompassPwaFileFitResults::ProdAmpsRootPwa( vector< complex<double> >& Destination ) const{
	Destination.clear();
	Destination.resize( _WaveNames.size() * _Rank - _Rank + 1 ); // Each rank for each wave has an entry, but the flatwave has only one entry

	TComplex ProdAmpTmp(0,0);

	unsigned int j=0; // Next free position in Destination
	for( unsigned int i=0; i < _WaveNames.size(); ++i ){
		if( "FLAT" == _WaveNames[i] ){
			ProdAmpTmp = _FitResults.get(i,0);
			Destination[j++] = complex<double>( ProdAmpTmp.Re(), ProdAmpTmp.Im() );
		}
		else{
			for( unsigned int k=0; k < _Rank; ++k ){
				ProdAmpTmp = _FitResults.get(i,k);
				Destination[j++] = complex<double>( ProdAmpTmp.Re(), ProdAmpTmp.Im() );
			}
		}
	}

	return Destination;
}

///< Returns _CovMatrix
const TMatrixT<double>& CompassPwaFileFitResults::CovMatrix() const{
	return _CovMatrix;
}

///< Returns a map for the covariance matrix as it is needed for root pwa
vector<pair<int, int> >& CompassPwaFileFitResults::CovMatrixMapRootPwa( vector<pair<int, int> >& Destination ) const{
	Destination.clear();
	Destination.reserve( _CovMatrixSize/2 );

	for( unsigned int i=0; i < _CovMatrixSize/2; ++i ){
		Destination.push_back( pair<int,int>( i*2, i*2+1 ) );
	}

	return Destination;
}

// Reads the rest of the information from a fit result file stream and returns 0 if no error occurred or a negative number as the error code
bool CompassPwaFileFitResults::ReadIn( std::istream& File ){
	bool Succesful = true; // Is set to false if an error occurs and returned at the end of the function
	stringstream LineStream;
	string Line;

	// Get number of events
	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "       33657"
		LineStream >> _NumEvents;

		if( !_NumEvents ){
			printErr << "Number of events either 0 or not an unsigned int\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "Number of events entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the number of events was expected\n";
		Succesful = false;
	}

	// Get log(likelihood)
	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": ""
		LineStream >> _LogLikelihood;

		if( !_LogLikelihood ){
			printErr << "log(likelihood) either 0 or not a double\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "log(likelihood) entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the log(likelihood) was expected\n";
		Succesful = false;
	}

	// Get fit status
	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "           0"
		LineStream >> _FitStatus;

		if( LineStream.fail() ){
			printErr << "fit status could not be read\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "log(likelihood) entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the fit status was expected\n";
		Succesful = false;
	}

	// Get number of reflectivity sections
	unsigned int NumSections = 0;

	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "           3"
		LineStream >> NumSections;

		if( !NumSections ){
			printErr << "Number of reflectivity sections either 0 or not a unsigned int\n";
			Succesful = false;
		}

		if( !LineStream.eof() ){
			printWarn << "Number of reflectivity sections entry longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the number of reflectivity sections was expected\n";
		Succesful = false;
	}

	// Get number of waves of each reflectivity section
	unsigned int SecNumWaves[NumSections];
	unsigned int NumWaves = 0;
	char semicolon = 0;

	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "    1;   45;    7;"
		for( unsigned int i = 0; i < NumSections; ++i){
			SecNumWaves[i] = 0;

			LineStream >> SecNumWaves[i] >> semicolon;

			if( !SecNumWaves[i] ){
				printErr << "Number of waves either 0 or not a unsigned int\n";
				Succesful = false;
			}
			else{
				if( semicolon != ';' ){
					printWarn << "Number of waves separator not a semicolon\n";
					if( _Debug ){
						printDebug << "Separator: '" << semicolon << "'\n";
					}
				}

				NumWaves += SecNumWaves[i];
			}
		}

		LineStream.get(); // Should not work, since line shouldn't have any more characters
		if( LineStream.good() ){
			printWarn << "Numbers of waves line longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the numbers of waves were expected\n";
		Succesful = false;
	}

	// Get rank of each reflectivity section
	unsigned int SecRank[NumSections];
	// The rank has to be the same for each section except the flatwave section, where the rank always will be 1
	bool RankException = false; // This variable will be set to true if a section with rank 1 is found, therefore if it's true and another section with rank 1 is found, all sections have to have rank 1
	semicolon = 0;

	if( GetNextValidLine( File, LineStream ) ){
		// Line example between "": "    1;    2;    2;"
		for( unsigned i = 0; i < NumSections; ++i){
			SecRank[i] = 0;

			LineStream >> SecRank[i] >> semicolon;

			if( !SecRank[i] ){
				printErr << "Rank either 0 or not a int\n";
				Succesful = false;
			}
			else{
				if( semicolon != ';' ){
					printWarn << "Rank separator not a semicolon\n";
					if( _Debug ){
						printDebug << "Separator: '" << semicolon << "'\n";
					}
				}

				if( _Rank != SecRank[i] ){
					if( RankException ){
						if( 0 == _Rank ){
							_Rank = SecRank[i];
						}
						else{
							printErr << "Rank of this section is " << SecRank[i] << " but the previous sections had rank " << _Rank << " and the section of the flat wave was already found\n";
							Succesful = false;
						}
					}
					else{
						if( (1 == SecRank[i]) && (1 == SecNumWaves[i]) ){ //it is possibly the flatwave section
							RankException = true;
						}
						else{
							if( 0 == _Rank ){
								_Rank = SecRank[i];
							}
							else{
								printErr << "Rank of this section is " << SecRank[i] << " but the previous sections had rank " << _Rank << " and it cannot be the section of the flat wave\n";
								Succesful = false;
							}
						}
					}
				}
			}
		}

		LineStream.get(); // Should not work, since line shouldn't have any more characters
		if( LineStream.good() ){
			printWarn << "Ranks line longer than expected\n";
		}
	}
	else{
		printErr << "No valid line could be found anymore, but the ranks were expected\n";
		Succesful = false;
	}

	// Get fit results
	char WaveNameCStr[61];
	string WaveName;
	WaveName.reserve(61);
	unsigned int LastNonEmptyCharacter;
	unsigned int CurRank;
	unsigned int l=0; // Loop variable equal to j except that it is not reseted to 0 for each section and therefore addresses _FitResults correctly
	unsigned int k; // Loop variable that is needed unchanged in a second loop
	_FitResults.ResizeTo(NumWaves,_Rank);
	complex<double> FitResultParameter;
	char apostrophe1; // Takes the first bracket character, which should be a apostrophe
	char apostrophe2; // Takes the second bracket character, which should be a apostrophe

	// if( _Debug ){ // Not always including it leads to compiler errors, even if it is not needed
	double RankSumProdAmpsSquared;
	// }

	for( unsigned i = 0; i < NumSections; ++i){
		for( unsigned j = 0; j < SecNumWaves[i]; ++j){
			if( GetNextValidLine( File, LineStream ) ){
				// Example:
				// 'FLAT                                                        '(-0.398790E-15;-0.824390E-15)
				//
				// '1-(0-+)0+ f0(1400) pi S                                     '( 0.209758E+00; 0.145496E+00)
				// '1-(0-+)0+ f0(980) pi S                                      '( 0.000000E+00; 0.000000E+00)( 0.000000E+00; 0.000000E+00)
				LineStream >> apostrophe1;
				LineStream.get( WaveNameCStr, 61 );
				LineStream >> apostrophe2;

				if( _Debug ){
					printDebug << "Name: "<< WaveNameCStr << '\n';
				}

				// if( _Debug ){ // Not always including it leads to compiler errors, even if it is not needed
				RankSumProdAmpsSquared = 0;
				// }

				// Fill the corresponding row of the matrix with the values from the file
				CurRank = min(SecRank[i],j+1);
				for( k = 0; k < CurRank; ++k){
					LineStream >> FitResultParameter;
					_FitResults.set( l, k, FitResultParameter );
					if( _Debug ){
						printDebug << "Rank"<<k<<": " << FitResultParameter << '\n';
						RankSumProdAmpsSquared += norm(FitResultParameter);
					}
				}

				if( _Debug ){
					printDebug << '\n';
				}

				// Fill the rest of the row of the matrix with (0,0), since in the Compass code result parameter that are always 0 are not included
				FitResultParameter = complex<double>(0,0);
				for( ; k < _Rank; ++k){
					_FitResults.set( l, k, FitResultParameter );
				}

				if( LineStream.fail() ){
					printErr << "Reading error in line " << l << " that is supposed to contain a fit result\n";
					Succesful = false;
				}
				else{
					LineStream.get(); // Should not work, since line shouldn't have any more characters
					if( LineStream.good() ){
						printWarn << "Fit result line longer than expected\n";
					}

					if( apostrophe1 != '\'' || apostrophe2 != '\'' ){
						printWarn << "Wave name bracket not an apostrophe\n";
						if( _Debug ){
							printDebug << "Brackets: '" << apostrophe1 << "','"<< apostrophe2 << "'\n";
						}
					}

					WaveName = WaveNameCStr;

					// Chop of following whitespaces
					LastNonEmptyCharacter = WaveName.find_last_not_of(' ');
					WaveName.resize(LastNonEmptyCharacter + 1);

					_WaveNames.push_back( WaveName );
					if( _Debug ){
						printDebug << MassBinStart() << '-' << MassBinEnd() << '_' << WaveName << ':' << RankSumProdAmpsSquared * _NumEvents << '\n';
					}
				}

				++l;
			}
			else{
				printErr << "Less wave names found than specified\n";
				Succesful = false;
			}
		}

		// After each section should be an empty line
		if( GetNextValidLine( File, Line ) ){
			if( !Line.empty() ){
				printErr << "More wave names found than specified\n";
				Succesful = false;
			}
		}
		else{
			printErr << "No valid line could be found anymore, but a blank separation line between reflectivity sections was expected\n";
			Succesful = false;
		}


	}

	// Get covariance matrix
	_CovMatrixSize = NumWaves*_Rank*2; // Real and imaginary entry for each rank of each wave
	if( RankException ){
		// Data contains flat wave with rank 1, therefore the size must be corrected
		_CovMatrixSize -= (_Rank-1)*2;
	}
	_CovMatrix.ResizeTo( _CovMatrixSize, _CovMatrixSize );

	for( unsigned int i = 0; i<_CovMatrixSize; ++i ){
		if( GetNextValidLine( File, LineStream ) ){
			// Line example between "": ""
			for( unsigned int j = 0; j<_CovMatrixSize; ++j ){
				LineStream >> _CovMatrix( i, j );
			}

			if( LineStream.fail() ){
				printErr << "Reading error in a line " << i+1 << " that is supposed to contain covariance matrix values (probably not enough entries)\n";
				Succesful = false;
			}

			if( !LineStream.eof() ){
				printErr << "Row of covariance matrix has too many entries\n";
				Succesful = false;
			}
		}
		else{
			printErr << "Covariance matrix has not enough rows\n";
			Succesful = false;
		}
	}

	// If there are still valid lines, the number of waves in the last section is not correct
	if( GetNextValidLine( File, Line ) ){
		// Some editors put automatically an empty line at the end, so this error has to be caught
		if( !Line.empty() || GetNextValidLine( File, Line ) ){
			printErr << "Covariance matrix has too many rows\n";
			Succesful = false;
		}
	}

	return Succesful;
}

// Prints all important variables of class
ostream& CompassPwaFileFitResults::Print(ostream& Out) const{
	CompassPwaFileBase::Print( Out );

	Out << "Number of events: " << _NumEvents << '\n';
	Out << "log(likelihood): " << _LogLikelihood << '\n';
	Out << "Rank: " << _Rank << '\n';

	for( unsigned int i=0; i < _WaveNames.size(); ++i){
		Out << '\'' << _WaveNames[i] << '\'';
		for( unsigned int k=0; k < _Rank; ++k ){
			Out << _FitResults.get(i,k);
		}
		Out << '\n';
	}

	return Out;
}

///< Returns true if CharToCheck is a Number or false if it isn't
bool CompassPwaFileFitResults::IsNumber( char CharToCheck ){
	return ( 47 < CharToCheck ) && ( CharToCheck < 58 );
}

// Converts a CompassPWA wavename into a rootpwa wavename and since rootpwa wavenames additionally include the rank it has to be provided separately (for the flatwave this value does not matter and can be left out)
bool CompassPwaFileFitResults::CompassPwaNameToRootPwaName( std::string& RootPwaDestination, const std::string& CompassPwaSource, unsigned int AddedRank ){
	bool Successful = true;

	if( _Debug ){
		printDebug << "Parsing name \"" << CompassPwaSource << "\"\n";
	}

	if ( "FLAT" == CompassPwaSource ){
		RootPwaDestination = "V_flat";
	}
	else{
		RootPwaDestination = CompassPwaSource;

		if( _Debug ){
			printDebug << "Check first 10 characters\n";
		}

		// Check if first 10 characters are valid
		if( !IsNumber(CompassPwaSource[0]) ){
			printErr << "At first position of the wave name is no number\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[1]) ){
			printErr << "At second position of the wave name is no sign\n";
			Successful = false;
		}
		if( '(' != CompassPwaSource[2] ){
			printWarn << "At third position of the wave name is no bracket\n";
		}
		if( !IsNumber(CompassPwaSource[3]) ){
			printErr << "At fourth position of the wave name is no number\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[4]) ){
			printErr << "At fifth position of the wave name is no sign\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[5]) ){
			printErr << "At sixth position of the wave name is no sign\n";
			Successful = false;
		}
		if( ')' != CompassPwaSource[6] ){
			printWarn << "At seventh position of the wave name is no bracket\n";
		}
		if( !IsNumber(CompassPwaSource[7]) ){
			printErr << "At eighth position of the wave name is no number\n";
			Successful = false;
		}
		if( !sign(CompassPwaSource[8]) ){
			printErr << "At ninth position of the wave name is no sign\n";
			Successful = false;
		}
		if( ' ' != CompassPwaSource[9] ){
			printWarn << "At tenth position of the wave name is no space\n";
		}

		if( _Debug ){
			printDebug << "Delete brackets and space in them\n";
		}

		// Remove braces and space in first 10 characters
		RootPwaDestination.erase(9,1);
		RootPwaDestination.erase(6,1);
		RootPwaDestination.erase(2,1);

		if( _Debug ){
			printDebug << "Find and replace isobar\n";
		}

		string Isobar;
		// Translate isobars
		unsigned int NumIsobars = 0;
		const unsigned int nmbDict = 6;
		vector<string> FindVec;

		// {rootpwa, CompassPWA}
		const string IsobarDictionary[nmbDict][2] = {
				{"sigma",    "f0(1400)"},
				{"f0(980)",    "f0(980)"},
				{"rho(770)",   "rho"},
				{"f2(1270)",   "f2"},
				{"rho3(1690)", "rho3"},
				{"f0(1500)", "f0(1500)"} };

		for (unsigned int i = 0; i < nmbDict; ++i){
			FindVec.clear();
			find_all( FindVec, RootPwaDestination, IsobarDictionary[i][1] );

			if( _Debug ){
				printDebug << RootPwaDestination << '\n';
				printDebug << "Find: \"" << IsobarDictionary[i][1] << "\" Found: " << FindVec.size() << '\n';
			}

			NumIsobars += FindVec.size();

			if( FindVec.size() > 0 ){
				Isobar = IsobarDictionary[i][0];
				if( IsobarDictionary[i][1] != IsobarDictionary[i][0] ){
					replace_all(RootPwaDestination, IsobarDictionary[i][1], IsobarDictionary[i][0] );
				}
			}
		}

		// Since root has problems with brackets they are deleted
		replace_all(RootPwaDestination, "(", "" );
		replace_all(RootPwaDestination, ")", "" );

		if( NumIsobars != 1 ){
			printErr << "Isobar of wave \"" << CompassPwaSource << "\" is not well-defined\n";
			Successful = false;
		}

		if( _Debug ){
			printDebug << "Isobar: \"" << Isobar << "\"\n";
			printDebug << "Find and replace L\n";
		}

		// Get && Translate L
		char L = 0;

		map<char, char> LDictionary;
		LDictionary['S'] = '0';
		LDictionary['P'] = '1';
		LDictionary['D'] = '2';
		LDictionary['F'] = '3';
		LDictionary['G'] = '4';
		LDictionary['H'] = '5';
		LDictionary['I'] = '6';
		LDictionary['K'] = '7';
		LDictionary['L'] = '8';

		int PosL = RootPwaDestination.find_last_of(' ') + 1;
		map<char,char>::iterator it = LDictionary.find( RootPwaDestination[PosL] );
		if( it == LDictionary.end() ){
			printErr << "L of wave is not well-defined\n";
			Successful = false;
		}
		else{
			L = it->second;
		}
		RootPwaDestination.erase(PosL-1);

		PosL = RootPwaDestination.find_last_of(' ');
		RootPwaDestination.erase( PosL, 1 );
		RootPwaDestination.insert( PosL, "_00_" ); // The 0s are just place holders
		RootPwaDestination[PosL+1] = L;
		const particleProperties *IsobarParticle = particleDataTable::entry( Isobar );
		if( !IsobarParticle ){
			printErr << "Spin of particle " << Isobar << " could not be determined\n";
			Successful = false;
		}
		else{
			if( IsobarParticle->J() > 9 ){
				printErr << "Particle spins with more than one digit have not been implemented into the wave name conversion yet";
				Successful = false;
			}
			else{
				RootPwaDestination[PosL+2] = 48 + IsobarParticle->J();
			}
		}

		if( _Debug ){
			printDebug << "Add rank\n";
		}

		// Insert the rank at the beginning of the wave name
		RootPwaDestination.insert( 0, "V0_" ); // The 0 is just a place holder
		if( AddedRank > 9 ){
			printErr << "Ranks with more than one digit have not been implemented into the wave name conversion yet";
			Successful = false;
		}
		else{
			RootPwaDestination[1] = 48 + AddedRank;
		}

		// At the end rootpwa always writes this
		RootPwaDestination.append(".amp");
	}

	return Successful;
}
