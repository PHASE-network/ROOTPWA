///////////////////////////////////////////////////////////////////////////
//
//    Copyright 2010
//
//    This file is part of rootpwa
//
//    rootpwa is free software: you can redistribute it and/or modify
//    it under the terms of the GNU General Public License as published by
//    the Free Software Foundation, either version 3 of the License, or
//    (at your option) any later version.
//
//    rootpwa is distributed in the hope that it will be useful,
//    but WITHOUT ANY WARRANTY; without even the implied warranty of
//    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//    GNU General Public License for more details.
//
//    You should have received a copy of the GNU General Public License
//    along with rootpwa.  If not, see <http://www.gnu.org/licenses/>.
//
///////////////////////////////////////////////////////////////////////////
//-------------------------------------------------------------------------
// File and Version Information:
// $Rev::                             $: revision of last commit
// $Author::                          $: author of last commit
// $Date::                            $: date of last commit
//
// Description:
//      Code file for the CompassPwaFileLoader class that provides
//		functionality to read in txt files generated by Compass pwa
//		and merge them to one root tree
//
//
// Author List:
//      Stephan Schmeing          TUM            (original author)
//
//
//-------------------------------------------------------------------------

#include <iostream>

#include "fileUtils.hpp"
#include "reportingUtils.hpp"
#include "particleDataTable.h"

#include "CompassPwaFileLoader.h"

using namespace std;
using namespace rpwa;

bool CompassPwaFileLoader::_Debug = false;

// Checks if the CompassPwaFileLoader object contains valid data
bool CompassPwaFileLoader::ValidityCheck() const{
	bool valid = true;

	if( _Debug ){
		printDebug << "Starting validity check\n";
	}

	// Do overlapping phase space integrals exist?
	if( _PhaseSpaceIntegrals.begin() == _PhaseSpaceIntegrals.end() ){
		printWarn << "No phase space integrals loaded\n";
	}
	else{
		for ( map<double, const CompassPwaFilePhaseSpaceIntegrals *>::const_iterator it = _PhaseSpaceIntegrals.begin(); ++it != _PhaseSpaceIntegrals.end();){
			if( (--it)->second->MassBinEnd() > (++it)->second->MassBinStart() ){
				printErr << "Mass bins of phase space integrals are overlapping: ("<< (--it)->second->MassBinStart() << '-' << it->second->MassBinEnd() << "),("<< (++it)->second->MassBinStart() << '-' << it->second->MassBinEnd() << ")\n";
				valid = false;
			}
		}
	}

	if( _Debug ){
		printDebug << "Phase space integral validity checked\n";
	}

	// Do overlapping normalization integrals exist?
	if( _PhaseSpaceIntegrals.begin() == _PhaseSpaceIntegrals.end() ){
		printWarn << "No normalization integrals loaded\n";
	}
	else{
		for ( map<double, const CompassPwaFileNormIntegrals *>::const_iterator it = _NormIntegrals.begin() ; ++it != _NormIntegrals.end(); ){
			if( (--it)->second->MassBinEnd() > (++it)->second->MassBinStart() ){
				printErr << "Mass bins of normalization integrals are overlapping: ("<< (--it)->second->MassBinStart() << '-' << it->second->MassBinEnd() << "),("<< (++it)->second->MassBinStart() << '-' << it->second->MassBinEnd() << ")\n";
				valid = false;
			}
		}
	}

	if( _Debug ){
		printDebug << "Normalization integral validity checked\n";
	}

	if( 0 == _FitResults.size() ){
		printWarn << "No fit results loaded\n";
	}

	return valid;
}

// Combines the matching integrals from _NormIntegrals to one for the given mass bin and given waves
bool CompassPwaFileLoader::DetermineNormIntegral( TCMatrix& Destination, const vector<string>& WaveNames, double MassBinStart, double MassBinEnd ){
	deque<const CompassPwaFileNormIntegrals *> NormIntegralSelection;

	if( _Debug ){
		printDebug << "Build normalization integral list from map\n";
	}
	map<double, const CompassPwaFileNormIntegrals *>::const_iterator it = _NormIntegrals.lower_bound(MassBinStart); // First Element of the integral map witch mass bin starts after MassBinStart

	if( it != _NormIntegrals.begin() ){
		if( (--it)->second->MassBinEnd() > MassBinStart ){
			// The mass bin of the element before it ends after MassBinStart and has to be copied to
			NormIntegralSelection.push_back( it->second );
		}
		(++it);
	}

	while( ( it != _NormIntegrals.end() ) && ( (it)->second->MassBinStart() < MassBinEnd ) ){
		NormIntegralSelection.push_back( (it++)->second );
	}

	if( _Debug ){
		printDebug << "Combine normalization integrals\n";
	}
	return CompassPwaFileNormIntegrals::Combine( Destination, NormIntegralSelection, WaveNames, MassBinStart, MassBinEnd );
}

// Combines the matching integrals from _PhaseSpaceIntegrals to one for the given mass bin and given waves
bool CompassPwaFileLoader::DeterminePhaseSpaceIntegral( vector<double>& Destination, const vector<string>& WaveNames, double MassBinStart, double MassBinEnd ){
	deque<const CompassPwaFilePhaseSpaceIntegrals *> PhaseSpaceIntegralSelection;

	map<double, const CompassPwaFilePhaseSpaceIntegrals *>::const_iterator it = _PhaseSpaceIntegrals.lower_bound(MassBinStart); // First Element of the integral map witch mass bin starts after MassBinStart

	if( it != _PhaseSpaceIntegrals.begin() ){
		if( (--it)->second->MassBinEnd() > MassBinStart ){
			// The mass bin of the element before it ends after MassBinStart and has to be copied to
			PhaseSpaceIntegralSelection.push_back( it->second );
		}
		(++it);
	}

	while( ( it != _PhaseSpaceIntegrals.end() ) && ( (it)->second->MassBinStart() < MassBinEnd ) ){
		PhaseSpaceIntegralSelection.push_back( (it++)->second );
	}

	return CompassPwaFilePhaseSpaceIntegrals::Combine( Destination, PhaseSpaceIntegralSelection, WaveNames, MassBinStart, MassBinEnd );
}

// Constructor which reads in the particleDataTable from ParticleDataFile to enable name conversion
CompassPwaFileLoader::CompassPwaFileLoader( const string& ParticleDataFile ){
	particleDataTable::readFile( ParticleDataFile );
}

// Destructor calls Clear function
CompassPwaFileLoader::~CompassPwaFileLoader(){
	Clear();
}

// Deletes all objects stored in the three maps
void CompassPwaFileLoader::Clear(){
	for ( map<double, const CompassPwaFileNormIntegrals *>::const_iterator it = _NormIntegrals.begin() ; it != _NormIntegrals.end(); it++ ){
		delete it->second;
	}
	_NormIntegrals.clear();

	for ( map<double, const CompassPwaFilePhaseSpaceIntegrals *>::const_iterator it = _PhaseSpaceIntegrals.begin() ; it != _PhaseSpaceIntegrals.end(); it++ ){
		delete it->second;
	}
	_PhaseSpaceIntegrals.clear();

	for ( unsigned int i = 0; i < _FitResults.size() ; ++i ){
		delete _FitResults[i];
	}
	_FitResults.clear();
}

// Takes a filename as parameter and reads in this file, sort and store it by its type, can be called multiple times and the new file is added, but since overlapping bins are not allowed for the integrals, reading multiple times the same file will cause an error in the merging function
void CompassPwaFileLoader::ReadFile( const string& FileName ){
	CompassPwaFileObject FileObject;
	CompassPwaFileObject::E_Status Status = CompassPwaFileObject::NotLoaded;

	Status = FileObject.ReadFromFile( FileName );

	switch( Status ){
	case CompassPwaFileObject::FitResult:
		_FitResults.push_back( static_cast<const CompassPwaFileFitResults *>( FileObject.DataObject() ) );
		break;
	case CompassPwaFileObject::PhaseSpaceIntegral:
		if( !( _PhaseSpaceIntegrals.insert( pair<double, const CompassPwaFilePhaseSpaceIntegrals *>(FileObject.MassBinStart(), static_cast<const CompassPwaFilePhaseSpaceIntegrals *>( FileObject.DataObject() ) ) ).second ) ){
			printErr << "Two phase space integral files with the same starting value are given to read in, but overlapping integrals are not allowed [mass bin>(" << FileObject.MassBinStart() << ',' << FileObject.MassBinEnd() << ")]\n";
		}
		break;
	case CompassPwaFileObject::AcceptanceCorrectedNormIntegral:
		// Acceptance corrected integrals are ignored
		delete FileObject.DataObject();
		break;
	case CompassPwaFileObject::NotAcceptanceCorrectedNormIntegral:
		if( !( _NormIntegrals.insert( pair<double, const CompassPwaFileNormIntegrals *>(FileObject.MassBinStart(), static_cast<const CompassPwaFileNormIntegrals *>( FileObject.DataObject() ) ) ).second ) ){
			printErr << "Two normalization integral files with the same starting value are given to read in, but overlapping integrals are not allowed [mass bin>(" << FileObject.MassBinStart() << ',' << FileObject.MassBinEnd() << ")]\n";
		}
		break;
	default:
		printErr << "Error reading file " << FileName << '\n';
		break;
	}

	// Ownership of DataObject passes with clearing to this class (CompassPwaFileLoader)
	FileObject.Clear();
}

// Takes a glob pattern as parameter and reads in all matching files, sorts and stores them by their type, can be called multiple times and the new files are added, but since overlapping bins are not allowed for the integrals, reading multiple times the same file will cause an error in the merging function
void CompassPwaFileLoader::ReadFiles( const std::string& GlobPattern ){
	vector<string> FileNames = filesMatchingGlobPattern( GlobPattern );

	for( unsigned int i = 0; i < FileNames.size(); ++i ){
		ReadFile( FileNames[i] );
	}
}

// Merges all previously read files to a tree containing objects of fitResult class
TTree *CompassPwaFileLoader::Merge(){
	if( ValidityCheck() ){
		if( _Debug ){
			printDebug << "Creating root tree\n";
		}
		// Creating root tree
		TTree *FitResultTree = new TTree("FitResultTree","Fit results");

		if( _Debug ){
			printDebug << "Done creating root tree\n";
		}

		if( FitResultTree ){
			// Adding branch to root tree
			fitResult *FitResult = 0;
			FitResultTree->Branch("FitResults", &FitResult);

			// Preparing variables for loop
			vector< complex<double> > ProdAmps;
			vector<string> WaveNames;
			vector< pair<int, int> > FitParCovMatrixIndices; // Indices of fit parameters for real and imaginary part in covariance matrix matrix
			TCMatrix NormIntegralValues;
			vector<double> PhaseSpaceIntegralValues;

			if( _Debug ){
				_FitResults[0]->WaveNamesRootPwa( WaveNames );
				for ( unsigned int i = 0; i < WaveNames.size() ; ++i ){
					printDebug << WaveNames[i] << '\n';
				}
			}

			// Looping over all CompassPWA fit results building root pwa fit results and storing them into the root tree
			for ( unsigned int i = 0; i < _FitResults.size() ; ++i ){
				if( _Debug ){
					printDebug << "Prozessing fit result " << i << '\n';
				}

				if( DetermineNormIntegral( NormIntegralValues, _FitResults[i]->WaveNames(), _FitResults[i]->MassBinStart(), _FitResults[i]->MassBinEnd() ) && DeterminePhaseSpaceIntegral( PhaseSpaceIntegralValues, _FitResults[i]->WaveNames(), _FitResults[i]->MassBinStart(), _FitResults[i]->MassBinEnd() ) ){
					// Create FitResult
					FitResult = new fitResult;

					if( FitResult ){
						// Fill FitResult
						if( _Debug ){
							printDebug << "Num Events\n";
							_FitResults[i]->NumEvents();
							printDebug << "Mass Bin\n";
							_FitResults[i]->MassBinStart();
							_FitResults[i]->MassBinEnd();
							printDebug << "LogLikelihood\n";
							_FitResults[i]->LogLikelihood();
							printDebug << "Rank\n";
							(int)(_FitResults[i]->Rank());
							printDebug << "ProdAmps\n";
							_FitResults[i]->ProdAmpsRootPwa( ProdAmps );
							printDebug << "WaveNames\n";
							_FitResults[i]->WaveNamesRootPwa( WaveNames );
							printDebug << "CovMatrix\n";
							_FitResults[i]->CovMatrix();
							printDebug << "CovMatrixMap\n";
							_FitResults[i]->CovMatrixMapRootPwa( FitParCovMatrixIndices );
							printDebug << "Fill result with data\n";
						}

						FitResult->fill(	_FitResults[i]->NumEvents(),
											_FitResults[i]->NumEvents(),
											(_FitResults[i]->MassBinStart() + _FitResults[i]->MassBinEnd() )/2,
											_FitResults[i]->LogLikelihood(),
											(int)(_FitResults[i]->Rank()),
											_FitResults[i]->ProdAmpsRootPwa( ProdAmps ),
											_FitResults[i]->WaveNamesRootPwa( WaveNames ),
											_FitResults[i]->CovMatrix(),
											_FitResults[i]->CovMatrixMapRootPwa( FitParCovMatrixIndices ),
											NormIntegralValues,
											PhaseSpaceIntegralValues,
											true,
											true );

						if( _Debug ){
							if( 0 == i ){
								printDebug << (*FitResult);
							}
						}

						// Fill FitResult into root tree
						if( _Debug ){
							printDebug << "Fill result in tree\n";
						}
						FitResultTree->Fill();

						// FitResult is copied to the tree and can be deleted
						if( _Debug ){
							printDebug << "Delete result\n";
						}
						delete FitResult;
						FitResult = 0;
					}
					else{
						printErr << "Could not allocate new FitResult\n";
					}
				}
				else{
					printErr << "Could not calculate integrals for mass bin (" << _FitResults[i]->MassBinStart() << '-' << _FitResults[i]->MassBinEnd() << ")\n";
				}

				if( _Debug ){
					printDebug << "Done prozessing fit result " << i << '\n';
				}
			}

			if( FitResultTree->GetEntries() ){
				printSucc << "Successfully added " << FitResultTree->GetEntries() << "fit results to the root tree\n";
			}
			else{
				printWarn << "No fit results added to the root tree";
			}
		}
		else{
			printErr << "Could not allocate new TTree\n";
		}

		return FitResultTree;
	}
	else{
		return 0;
	}
}
